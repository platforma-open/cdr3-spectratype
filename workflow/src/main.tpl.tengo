// CDR3 Spectratype workflow using pt library
wf := import("@platforma-sdk/workflow-tengo:workflow")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
ll := import("@platforma-sdk/workflow-tengo:ll")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
pt := import("@platforma-sdk/workflow-tengo:pt")

filter := func(arr, predicate) {
	filtered := []
	for item in arr {
		if predicate(item) {
			filtered = append(filtered, item)
		}
	}
	return filtered
}

/**
	Returns a spec for the given type of spectratype.
	
	Args:
		type: The type of spectratype to return (cdr3 or v).
		abundanceSpec: The spec for the abundance column.
		vGeneSpec: The spec for the vGene column.
		cdr3Spec: The spec for the cdr3Length column.
		lengthType: The type of sequence used as input.
		scChain: The chain (only when processing single cell data).
	
	Returns:
		A spec for the given type of spectratype.
*/
getSpecs := func(type, abundanceSpec, vGeneSpec, cdr3Spec, lengthType, scChain) {
	if type != "v" && type != "cdr3" {
		ll.panic("Invalid type: " + type)
	}

	spectratypeType := "pl7.app/vdj/" + type + "Spectratype"
	secondAxis := undefined
	label := undefined

	if type == "v" {
		label = "CDR3 V Spectratype"
		if lengthType != undefined {
			label = label + " (" + lengthType + ")"
		}
		if scChain != undefined {
			label = label + " " + scChain
		}
		secondAxis = {
			column: "vGene",
			spec: {
				name: vGeneSpec.name,
				type: "String",
				annotations: {
					"pl7.app/label": vGeneSpec.annotations["pl7.app/label"]
				},
				domain: vGeneSpec.domain
			}
		}
	} else if type == "cdr3" {
		label = "CDR3 Spectratype"
		if lengthType != undefined {
			label = label + " (" + lengthType + ")"
		}
		if scChain != undefined {
			label = label + " " + scChain
		}
		secondAxis = {
			column: "CDR3",
			spec: {
				name: "pl7.app/vdj/cdr3",
				type: "String",
				annotations: {
					"pl7.app/label": cdr3Spec.annotations["pl7.app/label"]
				},
				domain: cdr3Spec.domain
			}
		}
	} else {
		ll.panic("Invalid type: " + type)
	}
	return {
		axes: [
			{
				column: "Sample",
				spec: abundanceSpec.axesSpec[0]
			}, 
			{
				column: "cdr3Length",
				spec: {
					name: "pl7.app/vdj/cdr3Length",
					type: "Int",
					annotations: {
						"pl7.app/label": cdr3Spec.annotations["pl7.app/label"] + " length"
					},
					domain: cdr3Spec.domain
				}
			},
			secondAxis
			], 
			
		columns: [
			{
				column: "sum",
				spec: {
					name: spectratypeType,
					valueType: "Float",
					domain: {
						"pl7.app/vdj/cdr3Spectratype/type": "weighted",
						"pl7.app/abundance/unit": abundanceSpec.annotations["pl7.app/abundance/unit"]
					},
					annotations: {
						"pl7.app/label": label
					}
				}
			},
			{
				column: "size",
				spec: {
					name: spectratypeType,
					valueType: "Float",
					domain: {
						"pl7.app/vdj/cdr3Spectratype/type": "unweighted"
					},
					annotations: {
						"pl7.app/label": label + " (unweighted)"
					}
				}
			}],

		storageFormat: "Parquet",
		partitionKeyLength: 1
	}
}

wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains()
	bundleBuilder.addAnchor("main", args.datasetRef)

	// abundance
	bundleBuilder.addSingle({
		axes: [{ anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
			"pl7.app/isAbundance": "true",
			"pl7.app/abundance/normalized": "false",
			"pl7.app/abundance/isPrimary": "true"
		}
	}, "abundance")

	// cdr3
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/sequence",
		domain: {
			"pl7.app/vdj/feature": "CDR3",
			"pl7.app/alphabet": args.lengthType
		}
	}, "cdr3")

	// v-gene
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/geneHit",
		domain: {
			"pl7.app/vdj/reference": "VGene"
		}
	}, "vGene")

	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	columns := args.columns
	datasetSpec := columns.getSpec(args.datasetRef)
	isSingleCell := datasetSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey"

	cdr3Col := undefined
	vGeneCol := undefined
	if isSingleCell {
		predicate := func(col) {
			return col.spec.domain["pl7.app/vdj/scClonotypeChain"] == args.scChain && col.spec.domain["pl7.app/vdj/scClonotypeChain/index"] == "primary"
		}
		cdr3Cols := filter(columns.getColumns("cdr3"), predicate)
		ll.assert(len(cdr3Cols) == 1, "expected exactly 1 CDR3 column for chain, got %d", len(cdr3Cols))
		cdr3Col = cdr3Cols[0]

		vGeneCols := filter(columns.getColumns("vGene"), predicate)
		ll.assert(len(vGeneCols) == 1, "expected exactly 1 V gene column for chain, got %d", len(vGeneCols))
		vGeneCol = vGeneCols[0]
	} else {
		ll.assert(len(columns.getColumns("cdr3")) == 1, "expected exactly 1 CDR3 column, got ", len(columns.getColumns("cdr3")))
		ll.assert(len(columns.getColumns("vGene")) == 1, "expected exactly 1 V gene column, got ", len(columns.getColumns("vGene")))
		cdr3Col = columns.getColumns("cdr3")[0]
		vGeneCol = columns.getColumns("vGene")[0]
	}

	abundanceCol := columns.getColumn("abundance")
	abundanceSpec := columns.getSpec("abundance")
	
	cdr3LengthSpec := cdr3Col.spec
	vGeneSpec := vGeneCol.spec

	// Build TSV input for pt workflow
	table := pframes.tsvFileBuilder()
	table.mem("16GiB") // @TODO: set based on the size of the input
	table.cpu(4)

	table.setAxisHeader("pl7.app/sampleId", "Sample")
	table.add(cdr3Col, { header: "CDR3" })
	table.add(abundanceCol, { header: "weight" })
	table.add(vGeneCol, { header: "vGene" })
	tsv := table.build()

	// Use pt workflow instead of custom software
	ptWf := pt.workflow().
		mem("16GiB"). // @TODO: set based on the size of the input
		cpu(4)

	// Read the input data
	df := ptWf.frame(tsv, {xsvType: "tsv"})

	// Filter out rows with empty CDR3 to avoid problems
	dfFiltered := df.filter(
		pt.col("CDR3").isNotNull(),
		pt.col("CDR3").neq(pt.lit(""))
	)

	// Add CDR3 length column
	dfWithLength := dfFiltered.withColumns(
		pt.col("CDR3").strLenChars().alias("cdr3Length")
	)

	// V Spectratype: group by Sample, vGene, cdr3Length and aggregate
	vSpectratype := dfWithLength.
		groupBy("Sample", "vGene", "cdr3Length").
		agg(
			pt.col("weight").count().alias("size"),
			pt.col("weight").sum().alias("sum")
		)

	// CDR3 Spectratype: more complex logic
	// First, find top 20 CDR3s per sample
	cdr3Counts := dfWithLength.
		groupBy("Sample", "CDR3").
		agg(pt.col("weight").sum().alias("totalWeight"))

	// Rank CDR3s by weight within each sample (descending order)
	cdr3Ranked := cdr3Counts.withColumns(
		pt.rank(pt.col("totalWeight"), {descending: true}).over("Sample").alias("rank")
	)

	// Filter to top 20 CDR3s per sample and add marker column
	top20Cdr3 := cdr3Ranked.filter(
		pt.col("rank").le(pt.lit(20))
	).select(pt.col("Sample"), pt.col("CDR3")).withColumns(
		pt.lit(true).alias("isTop20")
	)

	// Join back with original data to mark top CDR3s
	dfWithTop20 := dfWithLength.join(top20Cdr3, {
		leftOn: ["Sample", "CDR3"],
		rightOn: ["Sample", "CDR3"],
		how: "left"
	})

	// Replace non-top CDR3s with "other"
	dfWithOther := dfWithTop20.withColumns(
		pt.when(pt.col("isTop20").isNull()).
			then(pt.lit("other")).
			otherwise(pt.col("CDR3")).
			alias("CDR3_final")
	)

	// CDR3 Spectratype: group by Sample, CDR3_final, cdr3Length and aggregate
	cdr3Spectratype := dfWithOther.
		groupBy("Sample", "CDR3_final", "cdr3Length").
		agg(
			pt.col("weight").count().alias("size"),
			pt.col("weight").sum().alias("sum")
		).
		select(
			pt.col("Sample"),
			pt.col("CDR3_final").alias("CDR3"),
			pt.col("cdr3Length"),
			pt.col("size"),
			pt.col("sum")
		)

	// Save both results
	vSpectratype.save("vSpectratype.result.tsv")
	cdr3Spectratype.save("cdr3Spectratype.result.tsv")

	// Run the pt workflow
	ptResult := ptWf.run()

	// Import results back to p-frames
	vSpectratypeResult := xsv.importFile(
		ptResult.getFile("vSpectratype.result.tsv"),
		"tsv",
		getSpecs("v", abundanceSpec, vGeneSpec, cdr3LengthSpec, args.lengthType, isSingleCell ? args.scChain : undefined),
		{splitDataAndSpec: true}
	)

	cdr3SpectratypeResult := xsv.importFile(
		ptResult.getFile("cdr3Spectratype.result.tsv"),
		"tsv",
		getSpecs("cdr3", abundanceSpec, vGeneSpec, cdr3LengthSpec, args.lengthType, isSingleCell ? args.scChain : undefined),
		{splitDataAndSpec: true}
	)

	// Make trace for provenance
	trace := pSpec.makeTrace(datasetSpec,
		{
			type: "milaboratories.cdr3-spectratype",
			importance: 50,
			label: "CDR3 Spectratype"
		})

	pf := pframes.pFrameBuilder()
	for id, v in vSpectratypeResult {
		pf.add(id + "-v", trace.inject(v.spec), v.data)
	}
	for id, v in cdr3SpectratypeResult {
		pf.add(id + "-cdr3", trace.inject(v.spec), v.data)
	}

	pf = pf.build()

	return {
		outputs: {
			pf: pframes.exportFrame(pf)
		},

		exports: {
			pf: pf
		}
	}
})

