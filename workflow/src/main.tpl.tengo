// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
ll := import("@platforma-sdk/workflow-tengo:ll")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")

filter := func(arr, predicate) {
	filtered := []
	for item in arr {
		if predicate(item) {
			filtered = append(filtered, item)
		}
	}
	return filtered
}

spectratype := assets.importSoftware("@platforma-open/milaboratories.cdr3-spectratype.software:main")

/**
	Returns a spec for the given type of spectratype.
	
	Args:
		type: The type of spectratype to return (cdr3 or v).
		abundanceSpec: The spec for the abundance column.
		vGeneSpec: The spec for the vGene column.
		cdr3Spec: The spec for the cdr3Length column.
		lengthType: The type of sequence used as input.
		scChain: The chain (only when processing single cell data).
	
	Returns:
		A spec for the given type of spectratype.
*/
getSpecs := func(type, abundanceSpec, vGeneSpec, cdr3Spec, lengthType, scChain) {
	if type != "v" && type != "cdr3" {
		ll.panic("Invalid type: " + type)
	}

	spectratypeType := "pl7.app/vdj/" + type + "Spectratype"
	secondAxis := undefined
	label := undefined

	if type == "v" {
		label = "CDR3 V Spectratype"
		if lengthType != undefined {
			label = label + " (" + lengthType + ")"
		}
		if scChain != undefined {
			label = label + " " + scChain
		}
		secondAxis = {
			column: "vGene",
			spec: {
				name: vGeneSpec.name,
				type: "String",
				annotations: {
					"pl7.app/label": vGeneSpec.annotations["pl7.app/label"]
				},
				domain: vGeneSpec.domain
			}
		}
	} else if type == "cdr3" {
		label = "CDR3 Spectratype"
		if lengthType != undefined {
			label = label + " (" + lengthType + ")"
		}
		if scChain != undefined {
			label = label + " " + scChain
		}
		secondAxis = {
			column: "CDR3",
			spec: {
				name: "pl7.app/vdj/cdr3",
				type: "String",
				annotations: {
					"pl7.app/label": cdr3Spec.annotations["pl7.app/label"]
				},
				domain: cdr3Spec.domain
			}
		}
	} else {
		ll.panic("Invalid type: " + type)
	}
	return {
		axes: [
			{
				column: "Sample",
				spec: abundanceSpec.axesSpec[0]
			}, 
			{
				column: "cdr3Length",
				spec: {
					name: "pl7.app/vdj/cdr3Length",
					type: "Int",
					annotations: {
						"pl7.app/label": cdr3Spec.annotations["pl7.app/label"] + " length"
					},
					domain: cdr3Spec.domain
				}
			},
			secondAxis
			], 
			
		columns: [
			{
				column: "sum",
				spec: {
					name: spectratypeType,
					valueType: "Float",
					domain: {
						"pl7.app/vdj/cdr3Spectratype/type": "weighted",
						"pl7.app/abundance/unit": abundanceSpec.annotations["pl7.app/abundance/unit"]
					},
					annotations: {
						"pl7.app/label": label
					}
				}
			},
			{
				column: "size",
				spec: {
					name: spectratypeType,
					valueType: "Float",
					domain: {
						"pl7.app/vdj/cdr3Spectratype/type": "unweighted"
					},
					annotations: {
						"pl7.app/label": label + " (unweighted)"
					}
				}
			}],

		storageFormat: "Binary",
		partitionKeyLength: 1
	}
}

wf.prepare(func(args) {
	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.ignoreMissingDomains()
	bundleBuilder.addAnchor("main", args.datasetRef)

	// abundance
	bundleBuilder.addSingle({
		axes: [{ anchor: "main", idx: 0 }, { anchor: "main", idx: 1 }],
		annotations: {
			"pl7.app/isAbundance": "true",
			"pl7.app/abundance/normalized": "false",
			"pl7.app/abundance/isPrimary": "true"
		}
	}, "abundance")

	// cdr3
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/sequence",
		domain: {
			"pl7.app/vdj/feature": "CDR3",
			"pl7.app/alphabet": args.lengthType
		}
	}, "cdr3")

	// v-gene
	bundleBuilder.addMulti({
		axes: [{ anchor: "main", idx: 1 }],
		name: "pl7.app/vdj/geneHit",
		domain: {
			"pl7.app/vdj/reference": "VGene"
		}
	}, "vGene")

	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {
	columns := args.columns
	datasetSpec := columns.getSpec(args.datasetRef)
	isSingleCell := datasetSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey"

	cdr3Col := undefined
	vGeneCol := undefined
	if isSingleCell {
		predicate := func(col) {
			return col.spec.domain["pl7.app/vdj/scClonotypeChain"] == args.scChain && col.spec.domain["pl7.app/vdj/scClonotypeChain/index"] == "primary"
		}
		cdr3Cols := filter(columns.getColumns("cdr3"), predicate)
		ll.assert(len(cdr3Cols) == 1, "expected exactly 1 CDR3 column for chain, got %d", len(cdr3Cols))
		cdr3Col = cdr3Cols[0]

		vGeneCols := filter(columns.getColumns("vGene"), predicate)
		ll.assert(len(vGeneCols) == 1, "expected exactly 1 V gene column for chain, got %d", len(vGeneCols))
		vGeneCol = vGeneCols[0]
	} else {
		ll.assert(len(columns.getColumns("cdr3")) == 1, "expected exactly 1 CDR3 column, got ", len(columns.getColumns("cdr3")))
		ll.assert(len(columns.getColumns("vGene")) == 1, "expected exactly 1 V gene column, got ", len(columns.getColumns("vGene")))
		cdr3Col = columns.getColumns("cdr3")[0]
		vGeneCol = columns.getColumns("vGene")[0]
	}

	abundanceCol := columns.getColumn("abundance")
	abundanceSpec := columns.getSpec("abundance")
	
	cdr3LengthSpec := cdr3Col.spec
	vGeneSpec := vGeneCol.spec

	table := pframes.tsvFileBuilder()

	table.setAxisHeader("pl7.app/sampleId", "Sample")
	table.add(cdr3Col, { header: "CDR3" })
	table.add(abundanceCol, { header: "weight" })
	table.add(vGeneCol, { header: "vGene" })
	tsv := table.build()

	runSpectratype := exec.builder().
		software(spectratype).
		addFile("input.tsv", tsv)

	if abundanceSpec.annotations["pl7.app/abundance/unit"] == "unweighted" {
		runSpectratype = runSpectratype.arg("--unweighted")
	}

	runSpectratype = runSpectratype.
		saveFile("vSpectratype.result.tsv").
		saveFile("cdr3Spectratype.result.tsv").
		run()

	vSpectratype := xsv.importFile(
		runSpectratype.getFile("vSpectratype.result.tsv"),
		"tsv",
		getSpecs("v", abundanceSpec, vGeneSpec, cdr3LengthSpec, args.lengthType, isSingleCell ? args.scChain : undefined),
		{splitDataAndSpec: true}
	)

	cdr3Spectratype := xsv.importFile(
		runSpectratype.getFile("cdr3Spectratype.result.tsv"),
		"tsv",
		getSpecs("cdr3", abundanceSpec, vGeneSpec, cdr3LengthSpec, args.lengthType, isSingleCell ? args.scChain : undefined),
		{splitDataAndSpec: true}
	)

	// Make trace for provenance
	trace := pSpec.makeTrace(datasetSpec,
		{
			type: "milaboratories.cdr3-spectratype",
			importance: 50,
			label: "CDR3 Spectratype"
		})

	pf := pframes.pFrameBuilder()
	for id, v in vSpectratype {
		pf.add(id + "-v", trace.inject(v.spec), v.data)
	}
	for id, v in cdr3Spectratype {
		pf.add(id + "-cdr3", trace.inject(v.spec), v.data)
	}
	pf = pf.build()

	return {
		outputs: {
			pf: pframes.exportFrame(pf)
		},

		exports: {
			pf: pf
		}
	}
})

